generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Project {
  id              Int              @id @default(autoincrement())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  title           String           @db.VarChar(255)
  content         String?
  published       Boolean          @default(false)
  users           UserProject[]
  tasks           Task[]           @relation("ProjectToTask")
  comments        Comment[]
  customProperties CustomProperty[] @relation("CustomPropertyToProject")
}

model Task {
  id              Int              @id @default(autoincrement())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  title           String           @db.VarChar(255)
  content         String?
  published       Boolean          @default(false)
  author          User             @relation("TaskToUser", fields: [userId], references: [id])
  userId          Int              @map("userId")
  projectId       Int              @map("projectId")
  project         Project          @relation("ProjectToTask", fields: [projectId], references: [id])
  customProperties CustomProperty[] @relation("CustomPropertyToTask")
}

model CustomProperty {
  id              Int              @id @default(autoincrement())
  key             String
  value           String           // Store the value as a string, can be parsed in application code
  type            CustomPropertyType
  projectId       Int?             // Nullable: Indicates this property belongs to a Project
  taskId          Int?             // Nullable: Indicates this property belongs to a Task
  project         Project?         @relation("CustomPropertyToProject", fields: [projectId], references: [id])
  task            Task?            @relation("CustomPropertyToTask", fields: [taskId], references: [id])
  options         CustomPropertyOption[] @relation("CustomPropertyToOptions") // Relation to store options for select/multi-select types

  @@index([projectId], name: "idx_custom_property_project")
  @@index([taskId], name: "idx_custom_property_task")
}

model CustomPropertyOption {
  id              Int              @id @default(autoincrement())
  value           String           // Store the option value
  customProperty  CustomProperty   @relation("CustomPropertyToOptions", fields: [customPropertyId], references: [id])
  customPropertyId Int

  @@index([customPropertyId], name: "idx_custom_property_option")
}

enum CustomPropertyType {
  STRING
  NUMBER
  SELECT
  MULTISELECT
  URL
}

model Comment {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  content    String
  author     User     @relation(fields: [userId], references: [id])
  userId     Int
  project    Project  @relation(fields: [projectId], references: [id])
  projectId  Int
}

model User {
  id         Int       @id @default(autoincrement())
  email      String    @unique
  name       String?
  password   String?
  projects   UserProject[]
  tasks      Task[]    @relation("TaskToUser")
  comments   Comment[]
}

model UserProject {
  userId     Int
  projectId  Int
  user       User     @relation(fields: [userId], references: [id])
  project    Project  @relation(fields: [projectId], references: [id])

  @@id([userId, projectId])
}
